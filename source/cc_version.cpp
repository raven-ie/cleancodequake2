/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/
/*
This source file is contained as part of CleanCode Quake2, a project maintained
by Paril, to 'clean up' and make Quake2 an easier source base to read and work with.

You may use any part of this code to help create your own bases and own mods off
this code if you wish. It is under the same license as Quake 2 source (as above),
therefore you are free to have to fun with it. All I ask is you email me so I can
list the mod on my page for CleanCode Quake2 to help get the word around. Thanks.
*/

//
// cc_version.cpp
// 
//

#include "cc_local.h"
#include "cc_version.h"

// Paril: Don't do this if we don't have STDC (Win32)
#if defined(CC_STDC_CONFORMANCE)
#undef VERSION_CHECKING
#define VERSION_CHECKING VC_NONE
#endif

// These three stay constant
void CheckNewVersion ();
void CheckVersionReturnance ();

#if VERSION_CHECKING == VC_CURL
#define CURL_STATICLIB
#include "curl\curl.h"
#endif

#define VERSION_PATH GAMENAME"/version.ver"
#define VERSION_URL "http://alteredsoftworks.com/cleancode/version.ver"

void WriteVersion ()
{
	fileHandle_t handle = FS_OpenFile (VERSION_PATH, FILEMODE_WRITE|FILEMODE_CREATE);

	if (!handle)
		return;

	FS_Print (handle, "%s %u %u %u", CLEANCODE_VERSION_PREFIX, CLEANCODE_VERSION_MAJOR_N, CLEANCODE_VERSION_MINOR_N, CLEANCODE_VERSION_BUILD_N);
	FS_Close (handle);
}

void VerifyVersionFile ()
{
	CFileBuffer Buffer (VERSION_PATH, true);
	CParser Parser (Buffer.GetBuffer<char> (), PSP_COMMENT_LINE);

	const char *token;

	std::cc_string prefix;
	Parser.ParseToken (PSF_ALLOW_NEWLINES, &token);
	prefix = token;

	uint8 minor;
	uint16 major;
	uint32 build;
	Parser.ParseDataType<uint16> (PSF_ALLOW_NEWLINES, &major, 1);
	Parser.ParseDataType<uint8> (PSF_ALLOW_NEWLINES, &minor, 1);
	Parser.ParseDataType<uint32> (PSF_ALLOW_NEWLINES, &build, 1);

	if (CompareVersion (prefix.c_str(), major, minor, build))
	{
		DebugPrintf ("Version file out of date; updating...\n");
		WriteVersion ();
	}
}

/*
======================================
BLANKS
======================================
*/

#if (VERSION_CHECKING == VC_NONE)
void CheckNewVersion ()
{
}

void CheckVersionReturnance ()
{
}

/*
======================================
WININET
======================================
*/

#elif (VERSION_CHECKING == VC_WININET)

#include <WinInet.h>
bool				VersionCheckReady;
std::cc_string		VersionPrefix;
uint8				VersionMajor;
uint16				VersionMinor;
uint32				VersionBuild;
EVersionComparison	VersionReturnance;
char				receiveBuffer[256];

#if defined(WIN32) && !defined(NO_MULTITHREAD_VERSION_CHECK)
HANDLE				hThread;
DWORD				iID;
long WINAPI CheckNewVersionThread (long lParam);

void CheckNewVersion ()
{
	if (hThread)
		return; // Already checking version..

	hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE)CheckNewVersionThread, NULL, 0, &iID);

	if (!hThread)
	{
		// Run it without a thread
		CheckNewVersionThread (0);
		CheckVersionReturnance ();
	}
}

long WINAPI CheckNewVersionThread (long lParam)
#else
void CheckNewVersion ()
#endif
{
	receiveBuffer[0] = 0;

	HINTERNET iInternetHandle = InternetOpenA ("wininet-agent/1.0", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
	
	Mem_Zero (receiveBuffer, sizeof(receiveBuffer));

	if (iInternetHandle)
	{
		HINTERNET iInternetFile = InternetOpenUrlA (iInternetHandle, VERSION_URL, NULL, 0, INTERNET_FLAG_RESYNCHRONIZE, INTERNET_NO_CALLBACK);
		if (iInternetFile)
		{
			// Start writing the file
			char *currentReceivePos = receiveBuffer;
			DWORD numBytesRead = 0;
#define READ_BYTES_SIZE 16

			while (true)
			{
				bool Passed = (!!InternetReadFile (iInternetFile, currentReceivePos, READ_BYTES_SIZE, &numBytesRead));
				if (!Passed || Passed && ((numBytesRead == 0) || numBytesRead < READ_BYTES_SIZE))
					break;
				currentReceivePos += READ_BYTES_SIZE;
			}

			InternetCloseHandle (iInternetFile);
		}
		InternetCloseHandle (iInternetHandle);
	}

	VersionCheckReady = true;

	return 0;
}

void CheckVersionReturnance ()
{
#if defined(WIN32) && !defined(NO_MULTITHREAD_VERSION_CHECK)
	if (VersionCheckReady)
	{
		if (receiveBuffer[0])
		{
			CParser Parser (receiveBuffer, PSP_COMMENT_LINE);

			const char *token;

			std::cc_string prefix;
			Parser.ParseToken (PSF_ALLOW_NEWLINES, &token);
			prefix = token;

			uint8 minor;
			uint16 major;
			uint32 build;
			Parser.ParseDataType<uint16> (PSF_ALLOW_NEWLINES, &major, 1);
			Parser.ParseDataType<uint8> (PSF_ALLOW_NEWLINES, &minor, 1);
			Parser.ParseDataType<uint32> (PSF_ALLOW_NEWLINES, &build, 1);

	#if defined(WIN32) && !defined(NO_MULTITHREAD_VERSION_CHECK)
			VersionReturnance = CompareVersion (prefix.c_str(), major, minor, build);
			VersionPrefix = prefix;
			VersionMinor = minor;
			VersionMajor = major;
			VersionBuild = build;
			VersionCheckReady = true;
	#else
			if (CompareVersion (prefix.c_str(), minor, major, build) == VERSION_NEWER)
				DebugPrintf (
				"==================================\n"
				"*****************************\n"
				"There is an update available for CleanCode!\n"
				"Please go to http://code.google.com/p/cleancodequake2 and update accordingly.\n"
				"Your version:   "CLEANCODE_VERSION_PRINT"\n"
				"Update version: "CLEANCODE_VERSION_PRINT"\n"
				"*****************************\n"
				"==================================\n",
				CLEANCODE_VERSION_PRINT_ARGS,
				prefix.c_str(), major, minor, build);
			else
				DebugPrintf ("Your version of CleanCode is up to date.\n");
	#endif
		}

		if (VersionReturnance == VERSION_NEWER)
			DebugPrintf (
			"==================================\n"
			"*****************************\n"
			"There is an update available for CleanCode!\n"
			"Please go to http://code.google.com/p/cleancodequake2 and update accordingly\nor run the auto updater."
			"Your version:   "CLEANCODE_VERSION_PRINT"\n"
			"Update version: "CLEANCODE_VERSION_PRINT"\n"
			"*****************************\n"
			"==================================\n",
			CLEANCODE_VERSION_PRINT_ARGS,
			VersionPrefix.c_str(), VersionMajor, VersionMinor, VersionBuild);
		else
			DebugPrintf ("Your version of CleanCode is up to date.\n");

		VersionReturnance = VERSION_SAME;
		VersionCheckReady = false;

		CloseHandle (hThread);

		hThread = NULL;
		iID = 0;
	}
#endif
}

/*
======================================
CURL
======================================
*/

#elif (VERSION_CHECKING == VC_CURL)
#include <curl/curl.h>
#include <curl/types.h>
#include <curl/easy.h>

struct MemoryStruct
{
	char *memory;
	size_t size;
};

static void *myrealloc(void *ptr, size_t size)
{
	/* There might be a realloc() out there that doesn't like reallocing
	NULL pointers, so we take care of it here */
	if(ptr)
		return Mem_ReAlloc (ptr, size);
	else
		return Mem_Alloc (size);
}

static size_t WriteMemoryCallback(void *ptr, size_t size, size_t nmemb, void *data)
{
	size_t realsize = size * nmemb;
	struct MemoryStruct *mem = (struct MemoryStruct *)data;

	mem->memory = (char*)myrealloc(mem->memory, mem->size + realsize + 1);

	if (mem->memory)
	{
		memcpy(&(mem->memory[mem->size]), ptr, realsize);
		mem->size += realsize;
		mem->memory[mem->size] = 0;
	}

	return realsize;
}

#if defined(WIN32) && !defined(NO_MULTITHREAD_VERSION_CHECK)
HANDLE				hThread;
DWORD				iID;
long WINAPI			CheckNewVersionThread (long lParam);
void				CheckVersionReturnance ();
bool				VersionCheckReady;
std::cc_string		VersionPrefix;
uint8				VersionMajor;
uint16				VersionMinor;
uint32				VersionBuild;
EVersionComparison	VersionReturnance;

void CheckNewVersion ()
{
	if (hThread)
		return; // Already checking version..

	hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE)CheckNewVersionThread, NULL, 0, &iID);

	if (!hThread)
	{
		// Run it without a thread
		CheckNewVersionThread (0);
		CheckVersionReturnance ();
	}
}

void CheckVersionReturnance ()
{
	if (VersionCheckReady)
	{
		if (VersionReturnance == VERSION_NEWER)
			DebugPrintf (
			"==================================\n"
			"*****************************\n"
			"There is an update available for Cl	eanCode!\n"
			"Please go to http://code.google.com/p/cleancodequake2 and update accordingly.\n"
			"Your version:   "CLEANCODE_VERSION_PRINT"\n"
			"Update version: "CLEANCODE_VERSION_PRINT"\n"
			"*****************************\n"
			"==================================\n",
			CLEANCODE_VERSION_PRINT_ARGS,
			VersionPrefix.c_str(), VersionMajor, VersionMinor, VersionBuild);
		else
			DebugPrintf ("Your version of CleanCode is up to date.\n");

		VersionReturnance = VERSION_SAME;
		VersionCheckReady = false;

		CloseHandle (hThread);

		hThread = NULL;
		iID = 0;
	}
}

long WINAPI CheckNewVersionThread (long lParam)
#else
void CheckNewVersion ()
#endif
{
	CURL *curl_handle;

	struct MemoryStruct chunk;

	chunk.memory=NULL; /* we expect realloc(NULL, size) to work */
	chunk.size = 0;    /* no data at this point */

	curl_global_init(CURL_GLOBAL_ALL);

	/* init the curl session */
	curl_handle = curl_easy_init();

	/* specify URL to get */
	curl_easy_setopt(curl_handle, CURLOPT_URL, "http://cleancodequake2.googlecode.com/svn/trunk/version.ver");

	/* send all data to this function  */
	curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);

	/* we pass our 'chunk' struct to the callback function */
	curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&chunk);

	/* some servers don't like requests that are made without a user-agent
	field, so we provide one */
	curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, "libcurl-agent/1.0");

	/* get it! */
	curl_easy_perform(curl_handle);

	/* cleanup curl stuff */
	curl_easy_cleanup(curl_handle);

	/*
	* Now, our chunk.memory points to a memory block that is chunk.size
	* bytes big and contains the remote file.
	*
	* Do something nice with it!
	*
	* You should be aware of the fact that at this point we might have an
	* allocated data block, and nothing has yet deallocated that data. So when
	* you're done with it, you should free() it as a nice application.
	*/

	if(chunk.memory)
	{
		CParser Parser (chunk.memory, PSP_COMMENT_LINE);

		const char *token;

		std::cc_string prefix;
		Parser.ParseToken (PSF_ALLOW_NEWLINES, &token);
		prefix = token;

		uint8 minor;
		uint16 major;
		uint32 build;
		Parser.ParseDataType<uint16> (PSF_ALLOW_NEWLINES, &major, 1);
		Parser.ParseDataType<uint8> (PSF_ALLOW_NEWLINES, &minor, 1);
		Parser.ParseDataType<uint32> (PSF_ALLOW_NEWLINES, &build, 1);

#if defined(WIN32) && !defined(NO_MULTITHREAD_VERSION_CHECK)
		VersionReturnance = CompareVersion (prefix.c_str(), major, minor, build);
		VersionPrefix = prefix;
		VersionMinor = minor;
		VersionMajor = major;
		VersionBuild = build;
		VersionCheckReady = true;
#else
		if (CompareVersion (prefix.c_str(), minor, major, build) == VERSION_NEWER)
			DebugPrintf (
			"==================================\n"
			"*****************************\n"
			"There is an update available for CleanCode!\n"
			"Please go to http://code.google.com/p/cleancodequake2 and update accordingly.\n"
			"Your version:   "CLEANCODE_VERSION_PRINT"\n"
			"Update version: "CLEANCODE_VERSION_PRINT"\n"
			"*****************************\n"
			"==================================\n",
			CLEANCODE_VERSION_PRINT_ARGS,
			prefix.c_str(), major, minor, build);
		else
			DebugPrintf ("Your version of CleanCode is up to date.\n");
#endif

		Mem_Free (chunk.memory);
	}

	/* we're done with libcurl, so clean it up */
	curl_global_cleanup();

	return 0;
}
#endif

void InitVersion ()
{
#if (VERSION_CHECKING != VC_NONE)
	DebugPrintf ("Checking for new version...\n");

	if (!FS_FileExists(VERSION_PATH))
	{
		DebugPrintf ("Version file non-existant, writing... ");
		WriteVersion ();
		DebugPrintf ("done\n");
	}
	else
		VerifyVersionFile ();
	
	CheckNewVersion ();
#endif
}

void Cmd_CCVersion_t (CPlayerEntity *Player)
{
	Player->PrintToClient (PRINT_HIGH, "This server is running CleanCode version "CLEANCODE_VERSION_PRINT"\n", CLEANCODE_VERSION_PRINT_ARGS);
}

void SvCmd_CCVersion_t ()
{
#if (VERSION_CHECKING != VC_NONE)
	if (ArgGets (2).empty())
#endif
		DebugPrintf ("This server is running CleanCode version "CLEANCODE_VERSION_PRINT"\n", CLEANCODE_VERSION_PRINT_ARGS);
#if (VERSION_CHECKING != VC_NONE)
	else
		CheckNewVersion ();
#endif
}

